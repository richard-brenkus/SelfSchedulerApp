package com.richardbrenkus.AnotherWebApp;
import java.sql.PreparedStatement;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.*;
//import java.sql.Date;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.annotation.CurrentSecurityContext;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.MissingServletRequestParameterException;
import org.springframework.web.bind.annotation.*;

//for form validation:
import javax.validation.Valid;
import javax.validation.constraints.Email;

import org.springframework.stereotype.Controller;
import org.springframework.validation.BindingResult;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;

 
@Controller
public class AppController {
	
	 List<String> professions = Arrays.asList("Developer", "Tester", "Architect");
	 
	 @Autowired // This means to get the bean called userRepository
	 // Which is auto-generated by Spring, we will use it to handle the data
	 private UserRepository userRepository;
	    
	 @Autowired
	 private Encoder encoder;
	 private String encodedPassword;
	    
	 @Autowired 
	 UserRoleRepository userRoleRepository; 
	
	 @GetMapping("/home")
	    public String index1() {
	    	return "home";
	 }
	 
	 @GetMapping("/")
	    public String index2() {
	    	return "home";
	 }
	 
	 @GetMapping("/index")
	    public String index3() {
	    	return "home";
	 }	 
/*/////////Recently swiched off:		 
	 @GetMapping("/admin/login")
	    public String adminLogin() {
		 	return "admin/login";
	 }

/*	 
	 @PostMapping("/logout")
	    public String logout() {
		 	return "home";
	 }
*/	 
	/* 
	 @PostMapping("/admin/login")
	    public String adminLoginPost() {
		 	return "admin/adminIndex";
	 }
	*////////////
	 
	 @GetMapping("/admin/adminIndex")
	    public String adminIndex(@CurrentSecurityContext(expression="authentication?.name") String name, Model model) {
		 
		 String displayName = userRepository.getUserByUsername(name).getName();
		 model.addAttribute("displayname", displayName);	 
		 return "admin/adminIndex";
	 }
	 
	/*	 
	 @GetMapping("/admin/login_success")
	    public String adminLoginSuccess() {
		 	return "admin/login_success";
	 }
	 
/*	 
	 @GetMapping("/user/login")
	    public String userLogin() {
		 	return "user/login";
	 }
	 
	 @PostMapping("/user/login")
	    public String userLoginPost() {
		 	return "user/userIndex";
	 }
*/	    	
	 @GetMapping("/user/userIndex")
	    public String userIndex(@CurrentSecurityContext(expression="authentication?.name") String name, Model model) {	 
		
		 String displayName = userRepository.getUserByUsername(name).getName();
		 model.addAttribute("displayname", displayName);
		 model.addAttribute("XdatePicker", new XdatePicker());
		 
		 return "user/userIndex";
	 }	 	
	
	     
    @GetMapping("/admin/register_merged")
    public String showForm(Model model) {
        User user = new User();
        model.addAttribute("user", user);               
        model.addAttribute("professions", professions);
         
        return "admin/register_merged";
    }
    
    @GetMapping("/add")
    public String showForm2(Model model) {
        User user = new User();
        model.addAttribute("user", user);
        model.addAttribute("professions", professions);
         
        return "admin/register_merged";
    }
    

/*    
    @PostMapping("/register")
    public String submitForm(@ModelAttribute("user") User user) {
        System.out.println(user);
        return "register_success";
    }
*/    
              
  
    @PostMapping(path="/add") // Map ONLY POST Requests
    public String addNewUser (@Valid User user, BindingResult bindingResult, @ModelAttribute ("user") @RequestParam String name, Model model, @RequestParam String email, @RequestParam String birthday,
    		@RequestBody String gender, @RequestParam String note, @RequestParam (name = "married", required = false) Boolean married, @RequestParam String profession , @RequestParam String username,
    		@RequestParam String password) {
    	// @ResponseBody means the returned String is the response, not a view name
    	// @RequestParam means it is a parameter from the GET or POST request
    	 	       	
    	if(bindingResult.hasErrors()) {
    		 model.addAttribute("professions", professions);
    		return "admin/register_merged";
    	} 
    	
    	
    	   	
    	if(gender.contains("gender=Male"))
    		gender = "Male";
    	else gender = "Female";
    	      	
    	User n = new User();  	
    	n.setCreationDate(LocalDateTime.now());
    	n.setName(name);
    	n.setUsername(username);
    	n.setEmail(email);
    	n.setBirthday(birthday);
       	n.setGender(gender);
      	if (married == null)
    		n.setMarried(false);
    	else n.setMarried(true);
    	n.setNote(note);
    	n.setEnabled(true);
    	encodedPassword = encoder.encode(password);
    	n.setPassword(encodedPassword.toString());
    	n.setProfession(profession);
    	    	  	

    	
    	Iterable<User> registeredUsers = userRepository.findAll();
    	
    	for (User registeredUser:registeredUsers) {
    		if (registeredUser.getUsername().equalsIgnoreCase(username)) {
    			bindingResult.rejectValue("username", "error.username", "This user name has already been used!");
    			model.addAttribute("professions", professions);
    			return "admin/register_merged";
    			} //close if username already present in DB
    		if (registeredUser.getEmail().equalsIgnoreCase(email)) {
    			bindingResult.rejectValue("email", "error.email", "This email address has already been used!");
    			model.addAttribute("professions", professions);
    	    	return "admin/register_merged";
    	    	} //close if email already present in DB
    		

    	} //close for
    	userRepository.save(n);
    	System.out.println("userRepository saved, no error");
		
		
		
		UserRole userRole = new UserRole();
    	userRole.setRole_id(1L);
    	userRole.setUser_id(n.getId());
    	userRoleRepository.save(userRole);
    
  //  	System.out.println("ID of role: " + r.getId());
   // 			usersRolesRepository.add(n.getId().toString(), "1");
    	//		usersRolesRepository.save(null)
    	System.out.println("userRoleRepository saved, no error");
//   		userRepository.save(r);
//   		System.out.println("roleRepository saved, no error");
    	registeredUsers = userRepository.findAll();
		return "admin/register_success";
		
    
    		
    			
    			    	
    	
}

    @GetMapping(path="/admin/all")
    public @ResponseBody Iterable<User> getAllUsers() {
    	// This returns a JSON or XML with the users
    	return userRepository.findAll();
}
 /*   
    @GetMapping("/admin/delete")
    public String selectUserToDelete(Model model) {
    	
    	List<String> usersList = new LinkedList<>();
    	
    	for(User user : userRepository.findAll())
    		usersList.add(user.getUsername());
    	
   //     User user = new User();
         
        model.addAttribute("usersList", usersList);
  //    model.addAttribute("user", user);
  //    model.addAttribute("professions", professions);
         
        return "admin/delete";
    }
 /*   
    @PostMapping("/admin/delete")
    public String deleteSelectedUser(User user, Model model, @RequestParam String username) {
    	
    	List<String> usersList = new LinkedList<>();
    	User deletedUser = user;

    	for(User userListed: userRepository.findAll())
    		if(userListed.getUsername().equalsIgnoreCase(username))
    			deletedUser = userListed;
    	
    	if(!deletedUser.equals(null))
    		userRepository.delete(deletedUser);
    	
    	for(User userListed : userRepository.findAll())
    		usersList.add(userListed.getUsername());
    	  	
   //     User user = new User();
         
        model.addAttribute("usersList", usersList);
  //    model.addAttribute("user", user);
  //    model.addAttribute("professions", professions);
         
        return "admin/delete_success";
    }
   */ 
    @GetMapping("/admin/delete/{id}")
    public String deleteUser(@PathVariable("id") long id, Model model) {

    	List<String> usersList = new LinkedList<>();
    	for(User userListed : userRepository.findAll())
    		usersList.add(userListed.getUsername());    	
    	model.addAttribute("users", usersList);
    	    	
    	
    	User user = userRepository.findById(id)
          .orElseThrow(() -> new IllegalArgumentException("Invalid user Id:" + id));
        userRepository.delete(user);
        return "redirect:/index";
    }
    
    @GetMapping("/admin/delete")
    public String deleteUserNoID(Model model) {
        User user = new User();
    	List<User> usersList = new LinkedList<>();
      	
    	for(User userListed : userRepository.findAll())
    		if(!userListed.getUsername().equalsIgnoreCase("admin"))
    			usersList.add(userListed);    	
    	model.addAttribute("users", usersList);
    	model.addAttribute("user", user);
    	
        return "admin/delete";
    }
    
    @PostMapping(path="/delete")
    public String deleteUser(@ModelAttribute ("user") User user, @RequestParam long id) {
     	   	
    	User deletedUser = user;
    	deletedUser = userRepository.findById(id)
    	          .orElseThrow(() -> new IllegalArgumentException("Invalid user Id:" + id));
    	userRepository.delete(deletedUser);
        
    	return "admin/delete_success";
    	 	
    }
    
    @GetMapping(path="/admin/update_select")
    public String updateUser(Model model) {     	 	   	       

    	final User updatedUser = new User();
       	List<User> usersList = new LinkedList<>();
       	
     	for(User userListed : userRepository.findAll())
     		usersList.add(userListed);    	
     	model.addAttribute("users", usersList);
     	model.addAttribute("updateduser", updatedUser);
     	System.out.println("@GetMapping(path=\"/admin/update_select\") finished correctly");
    
    	return "admin/update_select";
    	 	
    }
    
    @PostMapping(path="admin/updateFormSelect")
    public String updateFormGet(@ModelAttribute ("user") User user, @RequestParam String id, Model model) {
    		
    	 if (id.isEmpty())
    		 return "redirect:/admin/update_select"; 
    	
    	final User updatedUser;
    	final long longId;
    	
    	longId = Long.parseLong(id);

    	 updatedUser = userRepository.findById(longId)
   	          .orElseThrow(() -> new IllegalArgumentException("Invalid user Id:" + id));
    	 System.out.println("updatedUser object created successfully in  @PostMapping(path=\"admin/updateFormSelect\")");
    	   	 
    	     	 
    	 updatedUser.setPassword("");

    //	 User user = (User) model.getAttribute("updateduser");
    //	 System.out.println("updated user retrieved successfully");
    //   model.addAttribute("user", user);
         model.addAttribute("professions", professions);
         model.addAttribute("updateduser", updatedUser);
    	 System.out.println("updatedUser ID from updateFormSelect: " + updatedUser.getId());
     	 System.out.println("updatedUser from model 1: " + model.getAttribute("updateduser"));

       
         return "admin/update";
    }
    
    
    @PostMapping(path="/admin/updateForm")
    public String updateFormPost(@Valid @ModelAttribute ("updateduser") User updatedUser, BindingResult bindingResult, @RequestParam String name, Model model, @RequestParam String email, @RequestParam String birthday,
    		@RequestBody String gender, @RequestParam String note, @RequestParam (name = "married", required = false) Boolean married, @RequestParam String profession , @RequestParam String username,
    		@RequestParam String password, @RequestParam long id) {
     	
    	System.out.println("updatedUser from model 2: " + model.getAttribute("updateduser"));
    	
    	if(bindingResult.hasErrors()) {
   		 	model.addAttribute("professions", professions);
   		 	model.addAttribute("updateduser", updatedUser);
   		 	return "admin/update";
    	} 
    	
    	final User newUser = updatedUser;
    	User oldUser;
    	oldUser = userRepository.findById(id)
    	          .orElseThrow(() -> new IllegalArgumentException("Invalid user Id:" + id));
    	
    	newUser.setEnabled(true);
    	encodedPassword = encoder.encode(password);
    	newUser.setPassword(encodedPassword);
    	
    	Iterable<User> registeredUsers = userRepository.findAll();
    	
    	System.out.println("updatedUser username: " + updatedUser.getUsername());
    	System.out.println("username: " + username);
    	System.out.println("updatedUser email: " + updatedUser.getEmail());
    	System.out.println("email: " + email);
    	
    	for (User registeredUser:registeredUsers) {
    		if (registeredUser.getUsername().equalsIgnoreCase(username) && !registeredUser.equals(oldUser)) {
    	    	System.out.println("registered username: " + registeredUser.getUsername());
    	    	
    			bindingResult.rejectValue("username", "error.username", "This user name has already been used!");
    			model.addAttribute("professions", professions);
    			
    			newUser.setPassword("");
    			model.addAttribute("user", newUser);
    			
    			return "admin/update";
    			} //close if username already present in DB
    		
    		if (registeredUser.getEmail().equalsIgnoreCase(email) && !registeredUser.equals(oldUser)) {
    			System.out.println("registered email: " + registeredUser.getEmail());
    	    	
    			bindingResult.rejectValue("email", "error.email", "This email address has already been used!");
    			model.addAttribute("professions", professions);
    			
    			newUser.setPassword("");
    			model.addAttribute("user", newUser);
    			
    	    	return "admin/update";
    	    	} //close if email already present in DB
    	}//close for
    	
    	    	
    	userRepository.delete(oldUser);
    	System.out.println("old user deleted");
    	userRepository.save(newUser);
    	System.out.println("new user saved");
    	
    	userRepository.updateUserSetIdForUsername(oldUser.getId(), username);
    	System.out.println("User ID changed back to the original value");
    	
    	UserRole userRole = new UserRole();
    	userRole.setRole_id(1L);
    	userRole.setUser_id(oldUser.getId());
    	userRoleRepository.save(userRole);
    	System.out.println("Role updated");
    	
    	model.addAttribute("updateduser", newUser);
    
    	    	return "admin/update_success";
    	 	
    }
    
    @GetMapping ("/admin/users")
    public String showUsers(Model model) {
    	
    	List<User> usersList = new LinkedList<>();
      	
    	for(User userListed : userRepository.findAll())
    		usersList.add(userListed);    	
    	model.addAttribute("users", usersList);
    	return "admin/users";
    }   
    
    @GetMapping ("/user/datepicker")
    public String showDatePicker(Model model) {
    	 model.addAttribute("XdatePicker", new XdatePicker());
    	return "user/datepicker";
    }
    
    @PostMapping ("/user/datepicker")
    public String save(XdatePicker xdatePicker, Model model) {
        model.addAttribute("XdatePicker", xdatePicker);
        return "user/saved";
    }
    
       
    @PostMapping ("/date_submitted")
    public String dateSubmitted(@Valid @ModelAttribute ("XdatePicker") XdatePicker xdatePicker, BindingResult bindingResult, Model model, @CurrentSecurityContext(expression="authentication?.name") String name) {
    	    		
   		 String displayName = userRepository.getUserByUsername(name).getName();
   		 model.addAttribute("displayname", displayName); 
    	
    	if (bindingResult.hasFieldErrors("date")) {
    		bindingResult.rejectValue("date", "error.date", "a date");
    		 model.addAttribute("XdatePicker", xdatePicker);
    		 return "user/userIndex";
    	} //close if
    	
    	Request newRequest = new Request();
 //   	newRequest.setDateToString(xdatePicker.getDates());
    	newRequest.setDatesList(xdatePicker.getDates());

    	User user = userRepository.getUserByUsername(name);
 //   	newRequest.setUser(user);
    	user.setRequest_user(newRequest);
    	userRepository.save(user);
 
 /*   	
 //////////////convert String to List<Date>
    	List<Date> dateList = LocalDate.parse(userRepository.getUserByUsername(name).getRequest_user().getDates());
    	System.out.println("/n DATES: /n" + dateStrings.toString());
/////////////////
*/    	
        model.addAttribute("XdatePicker", xdatePicker);
        return "user/date_submitted";
    } //close PostMapping
    
    
    @GetMapping ("user/showRequestsInConsole")
    public String showRequestsInConsole(Model model, @CurrentSecurityContext(expression="authentication?.name") String name){
    	
    	User user = new User();
    	user = userRepository.getUserByUsername(name);
    	System.out.println("User:" + user.getName());
    	System.out.println("String dates: " + user.getRequest_user().getDates());
    	System.out.println("Date dates: " + user.getRequest_user().getDatesList().toString());
    	System.out.println("\n");
    	return "redirect:/user/userIndex";
    	
    }
    
    
    
         
}